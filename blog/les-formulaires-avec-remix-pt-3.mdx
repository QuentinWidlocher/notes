---
title: Les formulaires avec Remix - Partie 3
subtitle: G√©rer des donn√©es complexes avec nos formulaires
createdAt: 2022-03-01T00:00:00
cover:
  src: https://images.pexels.com/photos/374870/pexels-photo-374870.jpeg
  alt: Unrelated picture of a cityscape
series: Les formulaires avec Remix
lang: fr
---

Cet article fait suite √† celui-ci : [Les formulaires avec Remix - Partie 2](/blog/articles/les-formulaires-avec-remix-pt-2)

## R√©capitulatif

Dans le dernier article, on a vu comment automatiser la gestion et l'affichage des erreurs dans un formulaire remix et √ßa nous a fait gagner √©norm√©ment de temps.  
Maintenant, ces formulaires, aussi chouettes soient-ils, ne pousse pas le traitement de donn√©es bien loin.

Si vous avez d√©j√† jou√© avec des librairies de formulaire vous avez probablement l'habitude former des objets comportants plusieurs champs, et d'arranger vos formulaire autour de ces donn√©es.

Sauf qu'avec les formulaire HTML, vous n'avez pas le luxe d'organiser vos donn√©es en objets, ni m√™me en listes. Ils ne g√®rent pas non plus les dates, ni les bool√©ens vraiment.  
Bref, ils sont bien pratique et tr√®s simple, mais ils manquent de profondeur.

Notre but, c'est de pouvoir mod√©liser des donn√©es (via Typescript dans notre cas) et de pouvoir cr√©er des formulaires capable de repr√©senter ces donn√©es le plus pr√©cis√©ment possible, le tout avec le moins de manipulations √† fournir de la part du "d√©veloppeur final". (En gros, le dev qui va ajouter des features, pas celui qui met en place les outils de dev)

## Complexifions

Tout d'abord, changeons sch√©ma de donn√©es par un exemple plus complexe.

```typescript
interface Project {
	title: string;
	order: number;
	active: boolean;
	createdAt: Date;
	labels: string[];
	assigned: {
		firstName: string;
		lastName: string;
	};
}
```

On va donc g√©rer des "projets", c'est tr√®s conceptuel mais au moins on va pouvoir jouer avec diff√©rentes complexit√©s.  
Un projet a donc un titre, un ordre (d'affichage dans une liste pourquoi pas), une notion de projet actif ou non, une date de cr√©ation, une liste de libell√©s et une personne li√©e.

Ce sch√©ma va nous permettre de voir plusieurs type de donn√©es :

- Les cha√Ænes
- Les nombres
- Les bool√©ens
- Les dates
- Les listes
- Les objets

Mais √ßa vous le savez d√©j√† si vous avez lu le sommaire üòÖ

### Les chaines

Essayons maintenant une approche na√Øve de notre formulaire :

```tsx
<Form method="post">
	<label htmlFor="title">Project title</label>
	<input type="text" name="title" required />

	<button type="submit">Create this project</button>
</Form>
```

Pour le premiers champ, √ßa va, c'est relativement sens√©. Qu'est-ce qu'on re√ßoit cot√© serveur ?

```typescript
export let action: ActionFunction = async ({ request }) => {
	let formData = await request.formData();
	let formDataObj = Object.fromEntries(formData.entries());

	console.debug(formDataObj);
	/*
	 * {
	 *  title: 'Projet un',
	 * }
	 */

	return null;
};
```

L√† encore, c'√©tait attendu, on peut passer √† la suite.

### Les nombres

Ajoutons maintenant notre champs `order` qui est un nombre :

```tsx {5-6}
<Form method="post">
	<label htmlFor="title">Project title</label>
	<input type="text" name="title" required />

	<label htmlFor="order">Order in list</label>
	<input type="number" name="order" defaultValue={1} />

	<button type="submit">Create this project</button>
</Form>
```

Que voyons-nous cot√© serveur ?

```
{
  title: 'Projet un',
  order: '1'
}
```

Mince, d√©j√† le premier probl√®me, les nombres sont envoy√©s sous la forme de cha√Ænes √† notre serveur.  
Pas que les nombres d'ailleurs, mais toutes les donn√©es sont envoy√©s sous cette forme, c'est comme √ßa, c'est le fonctionnement de base des formulaires HTML, √† nous de nous adapter.

Ajoutons une fonction qui va nous permettre de transformer nos valeurs une √† une pour obtenir des r√©sultat plus int√©ressant

```typescript
// On imagine cette m√©thode appell√©e pour chaque cl√© de notre formDataObj
function parseFormDataValue<ExpectedType>(value: string): ExpectedType {
	// Une regex qui d√©tecte les nombres positifs et n√©gatifs √† virgules ou non
	if (/^[+-]?\d+(\.\d+)?$/.test(str)) {
		return parseFloat(str);
	}

	return value;
}
```

Voil√†, si un nombre passe par l√† sous la forme d'une cha√Æne, il ressortira sous la forme d'un nombre.

### Les bool√©ens

Ajoutons notre bool√©en.

```tsx {8-9}
<Form method="post">
	<label htmlFor="title">Project title</label>
	<input type="text" name="title" required />

	<label htmlFor="order">Order in list</label>
	<input type="number" name="order" defaultValue={1} />

	<label htmlFor="active">Is the project active ?</label>
	<input type="checkbox" name="active" />

	<button type="submit">Create this project</button>
</Form>
```

Oui, √ßa semble logique, une checkbox pour repr√©senter un bool√©en c'est ce qu'on a toujours fait.  
Mais que se passe-t'il si on envoi notre formulaire au serveur ?

```typescript
{
  title: 'Projet un',
  order: '1',
  active: 'on'
}
```

H√© non, pas de bool√©en ici mais un `'on'`. Plut√¥t curieux mais c'est le fonctionnement par d√©faut d'une checkbox html.  
Que se passe-t'il maintenant si on d√©coche la checkbox ? On devrait avoir un `'off'` non ?

```typescript
{
  title: 'Projet un',
  order: '1'
}
```

Ah ok, on a juste rien.  
En m√™me temps √ßa semble logique puisqu'il est impossible pour le formulaire de savoir si une checkbox est d√©coch√©e ou simplement non-remplie.

On peut aussi forcer la valeur √† passer √† la place de `'on'` en changeant l'attribut `value`.

<Tabs tabs={['Formulaire', 'Valeur re√ßue']}>
  ```tsx {9}
  <Form method="post">
    <label htmlFor="title">Project title</label>
    <input type="text" name="title" required />

    <label htmlFor="order">Order in list</label>
    <input type="number" name="order" defaultValue={1} />

    <label htmlFor="active">Is the project active ?</label>
    <input type="checkbox" name="active" value="true" />

    <button type="submit">Create this project</button>

  </Form>
  ```

```typescript
{
  title: 'Projet un',
  order: '1'
  active: 'true'
}
```

</Tabs>

Mais attention, la valeur retourn√©e sera toujours une cha√Æne, c'est bien `'true'` qu'on a ici et pas `true`.

Il nous faudrait donc un moyen de transformer un `'on'` ou un `'true'` en `true`. Pour g√©rer les `false` il faudra utiliser une valeur par d√©faut plus tard probablement.

Un truc dans ces eaux l√† :

```typescript {1-7,14-16}
// On indique quand m√™me comment g√©rer les false
// au cas o√π on les passe manuellement
const boolKeywords = {
	true: true,
	on: true,
	false: false,
	off: false,
};

function parseFormDataValue<ExpectedType>(value: string): ExpectedType {
	if (/^[+-]?\d+(\.\d+)?$/.test(str)) {
		return parseFloat(str);
	}

	if (value in boolKeywords) {
		return boolKeywords[value];
	}

	return value;
}
```

### Les dates

Ajoutons notre date.

```tsx {11-12}
<Form method="post">
	<label htmlFor="title">Project title</label>
	<input type="text" name="title" required />

	<label htmlFor="order">Order in list</label>
	<input type="number" name="order" defaultValue={1} />

	<label htmlFor="active">Is the project active ?</label>
	<input type="checkbox" name="active" />

	<label htmlFor="createdAt">Creation date</label>
	<input type="date" name="createdAt" />

	<button type="submit">Create this project</button>
</Form>
```

Et voyons ce que √ßa donne quand on valide le formulaire :

```typescript
{
  title: 'Projet un',
  order: '1',
  active: 'on',
  createdAt: '2022-02-23'
}
```

Bon, √ßa c'est pas tr√®s surprenant. On notera juste ici l'absence de temps (qu'il serait possible d'ajouter avec un champ `type="time"`)

Cette cha√Æne, on va devoir la transformer en `Date` pour pouvoir la manipuler.

```typescript {10-13}
function parseFormDataValue<ExpectedType>(value: string): ExpectedType {
	if (/^[+-]?\d+(\.\d+)?$/.test(str)) {
		return parseFloat(str);
	}

	if (value in boolKeywords) {
		return boolKeywords[value];
	}

	// Grosse regex pour g√©rer le m√™me format de date que celui du HTML
	// √† savoir YYYY-MM-DD et YYYY/MM/DD
	if (
		/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(str)
	) {
		return new Date(str);
	}

	return value;
}
```

### Les listes

Maintenant, comment ajouter une liste de cha√Ænes ? Ou une liste tout court d'ailleurs ?

Il n'existe rien en HTML qui permette √ßa nativement et aucune convention globale, c'est donc √† nous de d√©finir un moyen d'interpr√©ter des listes avec les moyens √† notre disposition.

Un moyen que j'ai vu plusieurs fois et qui est √† la fois simple √† mettre en place et tr√®s clair est de supposer un index √† notre champ comme ceci :

```tsx {14-19}
<Form method="post">
	<label htmlFor="title">Project title</label>
	<input type="text" name="title" required />

	<label htmlFor="order">Order in list</label>
	<input type="number" name="order" defaultValue={1} />

	<label htmlFor="active">Is the project active ?</label>
	<input type="checkbox" name="active" />

	<label htmlFor="createdAt">Creation date</label>
	<input type="date" name="createdAt" />

	<fieldset>
		<legend>Labels</legend>
		<input type="text" name="labels[0]" />
		<input type="text" name="labels[1]" />
		<input type="text" name="labels[2]" />
	</fieldset>

	<button type="submit">Create this project</button>
</Form>
```

On peut imaginer un bouton d'ajout de champs avec React par exemple

<details>
  <summary>Voir la version plus dynamique (juste pour l'exemple)</summary>

```tsx {2,21-35}
export default function createProjectRoute() {
	let [labelsNumber, setLabelsNumber] = useState(0);

	return (
		<Form method="post">
			<label htmlFor="title">Project title</label>
			<input type="text" name="title" required />

			<label htmlFor="order">Order in list</label>
			<input type="number" name="order" defaultValue={1} />

			<label htmlFor="active">Is the project active ?</label>
			<input type="checkbox" name="active" />

			<label htmlFor="createdAt">Creation date</label>
			<input type="date" name="createdAt" />

			<fieldset>
				<legend>Labels</legend>

				{Array(labelsNumber)
					.fill(0)
					.map((_, i) => (
						<input type="text" name={`labels[${i}]`} />
					))}

				<button type="button" onClick={() => setLabelsNumber((x) => x + 1)}>
					Add label
				</button>

				{labelsNumber > 0 ? (
					<button type="button" onClick={() => setLabelsNumber((x) => x - 1)}>
						Remove last label
					</button>
				) : null}
			</fieldset>

			<button type="submit">Create this project</button>
		</Form>
	);
}
```

Ici on garde dans un √©tat le nombre de champs, on boucle sur une liste vide juste pour cr√©er le bon nombre de champs et on donne la possibilit√© d'incr√©menter et de d√©cr√©menter le nombre de champs.

</details>

Et du coup, cot√© serveur on r√©cup√®re :

```typescript
{
  title: 'Projet un',
  order: '1',
  active: 'on',
  createdAt: '2022-02-23',
  'labels[0]': 'a',
  'labels[1]': 'b',
  'labels[2]': 'c'
}
```

On va bien entendu devoir transformer tous les champs avec des indexes en listes.

...

Bon l√† j'ai un peu la flemme d'impl√©menter √ßa en quelques ligne tout d'un coup, √ßa ne va pas tenir dans notre `parseFormDataValue()` puisqu'il faut voir toutes les valeurs pour les grouper en liste.

Je passe pour l'instant, peut-√™tre que la prochaine complexit√© sera plus simple ? üôÉ

### Les objets

Le m√™me probl√®me se pose pour les objets que pour les listes, il n'existe pas de solution en HTML et pas de convention globale.

On peut appliquer la m√™me solution cependant en utilisant le m√™me syst√®me de notation d'objet en javascript, comme on a fait avec les indexes tout √† l'heure.

```tsx {21-29}
<Form method="post">
	<label htmlFor="title">Project title</label>
	<input type="text" name="title" required />

	<label htmlFor="order">Order in list</label>
	<input type="number" name="order" defaultValue={1} />

	<label htmlFor="active">Is the project active ?</label>
	<input type="checkbox" name="active" />

	<label htmlFor="createdAt">Creation date</label>
	<input type="date" name="createdAt" />

	<fieldset>
		<legend>Labels</legend>
		<input type="text" name="labels[0]" />
		<input type="text" name="labels[1]" />
		<input type="text" name="labels[2]" />
	</fieldset>

	<fieldset>
		<legend>Assigned person</legend>

		<label htmlFor="assigned.firstName">First name</label>
		<input type="text" name="assigned.firstName" />

		<label htmlFor="assigned.lastName">Last name</label>
		<input type="text" name="assigned.lastName" />
	</fieldset>

	<button type="submit">Create this project</button>
</Form>
```

Comme vous pouvez le constater, on ajoute chaque champ √† la suite mais en indiquant la position dans l'objet final avec `assigned.firstName`.  
On peut imaginer des objets plus imbriqu√© comme `assigned.knowledge.remix.score` voire m√™me carr√©ment m√©langer des objets imbriqu√© et des listes avec `assigned.favoriteFrameworks[0].name` !

Mais je m'emporte, passons √† l'impl√©mentation de ces champs infiniment imbriqu√©s :

...

üò©

L√† je jette l'√©ponge, on ne va pas passer une semaine √† am√©liorer notre gestion des formulaires pour gagner 2h au total. √Ä moins que...

## `qs` le parser de query string

Bien entendu, √† chaque fois qu'il faudrait cr√©er un sous-projet pour r√©pondre √† un besoin, on peut √™tre s√ªr que des gens l'ont d√©j√† probablement fait et c'est le cas avec [`qs`](https://github.com/ljharb/qs) qui a pour but de transformer une query string :

```
?key=value&arr[0]=a&arr[1]=b&obj.key=objvalue
```

en

```typescript
{
  key: "value",
  arr: [
    "a", "b"
  ],
  obj: {
    key: "objvalue"
  },
}
```

Et qui pourra donc transformer :

```
?title=Projet+1&order=1&active=on&createdAt=2022-02-23&labels%5B0%5D=a&labels%5B1%5D=b&labels%5B2%5D=c&assigned.firstName=Quentin&assigned.lastName=Widlocher
```

en

```typescript
{
  title: 'Projet 1',
  order: '1',
  active: 'on',
  createdAt: '2022-02-23',
  labels: [ 'a', 'b', 'c' ],
  assigned: { firstName: 'Quentin', lastName: 'Widlocher' }
}
```

Super ! Mais √ßa ne g√®re pas les valeurs num√©riques, bool√©ennes et de date √ßa.  
(Au moins le code d'avant n'est pas √† jeter !)

> [Si vous voulez comprendre pourquoi `qs` ne g√®re pas √ßa](https://github.com/ljharb/qs#parsing-primitivescalar-values-numbers-booleans-null-etc)

### Impl√©menter `qs`

Pour commencer on va avoir besoin d'ajouter `qs` √† notre projet

<Tabs tabs={["yarn", "npm"]}>
	```
		yarn add qs
		yarn add -D @types/qs
	```

    ```
    	npm i --save qs
    	npm i --save-dev @types/qs
    ```

</Tabs>

Ensuite, pour fournir une query string √† `qs`, il va nous falloir transformer notre formData. Heureusement, il existe des m√©thode natives

```typescript
export let action: ActionFunction = async ({ request }) => {
	// On r√©cup√®re notre formData
	let formData = await request.formData();

	// On transforme ses entr√©es en une liste √† deux dimensions
	let formDataEntries = [...formData.entries()] as string[][];

	// Et cette liste peut √™tre transform√© avec la classe URLSearchParams
	let queryParams = new URLSearchParams(formDataEntries).toString();

	console.debug(queryParams);
	// title=Projet+1&order=1&active=on&createdAt=2022-02-23&labels%5B0%5D=a& ...

	return null;
};
```

Maintenant qu'on a cette query string, on va pouvoir la parse √† l'aide de `qs`

```typescript {1,10}
import qs from "qs"

export let action: ActionFunction = async ({ request }) => {
	let formData = await request.formData()
	let formDataEntries = [...formData.entries()] as string[][]
	let queryParams = new URLSearchParams(formDataEntries).toString()

	// Ici on passe { allowDots: true } pour faire fonctionner notre
	// √©criture du style `obj.key`
	let parsed = qs.parse(queryParams, { allowDots: true })

	console.debug(parsed)
	/*	{
	 *		title: 'Projet 1',
	 *		order: '1',
	 *		active: 'on',
	 *		createdAt: '2022-02-23',
	 *		labels: [ 'a', 'b', 'c' ],
	 *		assigned: { firstName: 'Quentin', lastName: 'Widlocher' }
	 */	}

	return null
}
```

### On rajoute nos primitives

Et maintenant ? Comment on parse nos primitives (dates, bool√©ens, etc.) ?

Soit on fait cette fameuse fonctions qui va boucler sur les propri√©t√©s de notre objet mais √ßa peut √™tre gal√®re puisqu'il faudrait boucler de mani√®re r√©cursive.

Soit on profite de `qs` et de son option `decoder` qui permet... de faire exactement ce qu'on a besoin de faire !

```typescript {1,10}
import qs, { IParseOptions } from "qs";

let customDecoder: IParseOptions["decoder"] = (str, decoder, charset) => {
	// On va avoir besoin de g√©rer un peu plus pr√©cisement nos valeurs
	// donc un peu plus de cambouis sur les mains

	// On skip nos chaines vides
	if (str.length === 0) {
		return;
	}

	// On parse nos nombres
	if (/^(\d+|\d*\.\d+)$/.test(str)) {
		return parseFloat(str);
	}

	// On remplace les cha√Ænes avec des mot-cl√©s par leurs valeur
	// (uniquement si on souhaite pouvoir passer des null et des undefined)
	const keywords = {
		null: null,
		undefined,
	};
	if (str in keywords) {
		// Typescript crie parce qu'il a peur d'acc√©der √† keywords[str]
		// malgr√®s notre v√©rification

		// @ts-expect-error si on peut
		return keywords[str];
	}

	// On parse nos bool√©ens
	const boolKeywords = {
		true: true,
		on: true,
		false: false,
		off: false,
	};
	if (str in boolKeywords) {
		// Typescript crie parce qu'il a peur d'acc√©der √† boolKeywords[str]
		// malgr√®s notre v√©rification

		// @ts-expect-error si on peut
		return boolKeywords[str];
	}

	// On parse nos dates
	if (
		/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(str)
	) {
		return new Date(str);
	}

	// Si on est arriv√© l√†, c'est qu'on a une cha√Æne.

	// On retire les + et les %20 √† la place des espaces
	const strWithoutPlus = str.replace(/\+/g, " ");
	if (charset === "iso-8859-1") {
		return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
	}

	// Et on essaye aussi de d√©coder le caract√®res du genre ? = & /
	try {
		return decodeURIComponent(strWithoutPlus);
	} catch (e) {
		return strWithoutPlus;
	}
};

export let action: ActionFunction = async ({ request }) => {
	let formData = await request.formData();
	let formDataEntries = [...formData.entries()] as string[][];
	let queryParams = new URLSearchParams(formDataEntries).toString();

	let parsed = qs.parse(queryParams, {
		allowDots: true,
		decoder: customDecoder,
	});

	return null;
};
```

Et le moment que vous attendiez tous, la valeur finale de `parsed` :

```typescript
{
  title: 'Projet 1',
  order: 1,
  active: true,
  createdAt: 2022-02-23T00:00:00.000Z,
  labels: [ 'a', 'b', 'c' ],
  assigned: { firstName: 'Quentin', lastName: 'Widlocher' }
}
```

Tada ! üéâ

Et voil√†, on a d√©sormais un outil de quelques ligne qui nous permet de passer d'une liste de champs format cha√Æne √† des objets complexe avec des primitives et Tout

Il ne reste plus qu'√† brancher `zod` comme dans l'article d'avant et √† vous le plaisir d'impl√©menter des formulaire HTML natifs !  
Je laisse bien s√ªr cet exercice aux lecteurs.

...

Mais non bien s√ªr, si vous voulez profitez de toute la puissance de `zod` et de `qs` pour le traitement de vos formulaires, mais aussi plein d'autre moyens de vous faire gagner du temps et de l'√©nergie sur vos projets Remix, je vous invite √† jeter un coup d'oeil √† ma [**Template Remix**](https://github.com/QuentinWidlocher/remix-template)

Vous y trouverez un moyen de lancer un projet Remix avec tout ce qui faut pour g√©rer une base de donn√©es, des formulaires complexes, la synchronisation des types entre le serveur et le client etc.

Tailwind y est d√©j√† int√©gr√© ainsi que Prisma et SuperJSON, si vous avez des id√©es, n'h√©sitez pas √† m'en parler sur la page Github üòâ

√Ä bient√¥t j'esp√®re !

<details>
	<summary>Code complet</summary>

    ```tsx
    import qs, { IParseOptions } from "qs";
    import { ActionFunction, Form } from "remix";

    let customDecoder: IParseOptions["decoder"] = (str, decoder, charset) => {
    	// On va avoir besoin de g√©rer un peu plus pr√©cisement nos valeurs
    	// donc un peu plus de cambouis sur les mains

    	// On skip nos chaines vides
    	if (str.length === 0) {
    		return;
    	}

    	// On parse nos nombres
    	if (/^(\d+|\d*\.\d+)$/.test(str)) {
    		return parseFloat(str);
    	}

    	// On remplace les cha√Ænes avec des mot-cl√©s par leurs valeur
    	// (uniquement si on souhaite pouvoir passer des null et des undefined)
    	const keywords = {
    		null: null,
    		undefined,
    	};
    	if (str in keywords) {
    		// Typescript crie parce qu'il a peur d'acc√©der √† keywords[str]
    		// malgr√®s notre v√©rification

    		// @ts-expect-error si on peut
    		return keywords[str];
    	}

    	// On parse nos bool√©ens
    	const boolKeywords = {
    		true: true,
    		on: true,
    		false: false,
    		off: false,
    	};
    	if (str in boolKeywords) {
    		// Typescript crie parce qu'il a peur d'acc√©der √† boolKeywords[str]
    		// malgr√®s notre v√©rification

    		// @ts-expect-error si on peut
    		return boolKeywords[str];
    	}

    	// On parse nos dates
    	if (
    		/^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(str)
    	) {
    		return new Date(str);
    	}

    	// Si on est arriv√© l√†, c'est qu'on a une cha√Æne.

    	// On retire les + et les %20 √† la place des espaces
    	const strWithoutPlus = str.replace(/\+/g, " ");
    	if (charset === "iso-8859-1") {
    		return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    	}

    	// Et on essaye aussi de d√©coder le caract√®res du genre ? = & /
    	try {
    		return decodeURIComponent(strWithoutPlus);
    	} catch (e) {
    		return strWithoutPlus;
    	}
    };

    export let action: ActionFunction = async ({ request }) => {
    	let formData = await request.formData();
    	let formDataEntries = [...formData.entries()] as string[][];
    	let queryParams = new URLSearchParams(formDataEntries).toString();

    	let parsed = qs.parse(queryParams, {
    		allowDots: true,
    		decoder: customDecoder,
    	});

    	return null;
    };

    export default function Index() {
    	return (
    		<Form method="post">
    		<label htmlFor="title">Project title</label>
    		<input type="text" name="title" required />

    		<label htmlFor="order">Order in list</label>
    		<input type="number" name="order" defaultValue={1} />

    		<label htmlFor="active">Is the project active ?</label>
    		<input type="checkbox" name="active" />

    		<label htmlFor="createdAt">Creation date</label>
    		<input type="date" name="createdAt" />

    		<fieldset>
    			<legend>Labels</legend>
    			<input type="text" name="labels[0]" />
    			<input type="text" name="labels[1]" />
    			<input type="text" name="labels[2]" />
    		</fieldset>

    		<fieldset>
    			<legend>Assigned person</legend>

    			<label htmlFor="assigned.firstName">First name</label>
    			<input type="text" name="assigned.firstName" />

    			<label htmlFor="assigned.lastName">Last name</label>
    			<input type="text" name="assigned.lastName" />
    		</fieldset>

    		<button type="submit">Create this project</button>
    		</Form>
    	);
    }

    ```

</details>
