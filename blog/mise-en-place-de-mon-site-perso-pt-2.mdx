---
title: Mise en place de mon site perso - Partie 2
subtitle: Lancement du projet et choix technologiques
createdAt: "2022-03-16T00:00:00"
series: Mise en place de mon site perso
cover:
  src: https://images.pexels.com/photos/11467701/pexels-photo-11467701.jpeg
  alt: Unrelated picture of a tall glass building, by Kelly Lacy
lang: fr
---

## Lancement

Autant j'ai passÃ© beaucoup de temps Ã  crÃ©er [Remix Template](https://github.com/QuentinWidlocher/remix-template) pour gagner du temps lors de la mise en place de mes projets Remix, autant dans ce cas j'ai pressenti que je n'en aurais pas besoin.

Remix Template fourni tout ce qu'il faut pour crÃ©er des applications, avec des formulaires intelligents, une connexion Ã  une base de donnÃ©es etc.

Dans le cas de mon site personnel, tout ce que j'avais besoin c'Ã©tait d'ajouter Tailwind et peut-Ãªtre une ou deux fonction utilitaire que j'ai copiÃ© de Remix Template.

### Architecture des fichiers

Pour bien travailler il faut bien ranger ~~sa chambre~~ son code c'est bien connu !

Pour mes projets React j'ai pris l'habitude de me baser sur [Bulletproof React](https://github.com/alan2207/bulletproof-react), en ce qui concerne le dÃ©coupage des fichiers.

#### Bulletproof React

Je ne vais pas dÃ©tailler ici toutes les opinions apportÃ©es par Bulletproof React mais voici en tout cas ce que j'en ai empruntÃ© et que je conserve dans un coin de ma tÃªte pour la grande majoritÃ© de mes projets perso.

Pour dÃ©couper une application, je rÃ©sonne d'abord en terme de _features_ (et non pas de pages, ou d'entitÃ© de base de donnÃ©es ou autre). Dans mon cas, j'ai rÃ©flÃ©chi aux grandes _features_ de mon site et j'ai choisi Ã§a :

- L'aspect Accueil, c'est trÃ¨s vide mais c'est quand mÃªme une _feature_ pour moi
- L'aspect Github, avec la connexion Ã  leur API, les pages repos et stars etc.
- L'aspect blog, avec mes posts, la connexion Ã  mon repo d'articles etc. (je spoil)

Donc mon architecture ressemble Ã  Ã§a :

```
app/
â”œâ”€ features/
â”‚  â”œâ”€ github/
â”‚  â”œâ”€ blog/
â”‚  â”œâ”€ home/
â”œâ”€ routes/
public/
```

Ensuite, dans chaque _feature_ (et dans le dossier `app` qui reprÃ©sente un peu une _feature_ globale), j'ajoute ces dossiers au besoin :

- `api` pour les wrappers d'API
- `components` pour les composants
- `loaders` pour isoler les loaders et leurs types de retour
- `pages` pour le composant racine de chaque page
  - Les pages prennent uniquement des props et n'utilisent pas de hooks du genre `useLoaderData()` car je veux pouvoir les rÃ©utiliser dans des contexte diffÃ©rent comme des modales ou autre
- `styles` pour les rares cas oÃ¹ j'ai besoin de CSS custom (la font monospace dans les articles par exemple)
- `types` pour centraliser tous les types d'une feature
- `utils` pour toutes les petites fonctions utilitaires spÃ©cifiques

<details>
  <summary>Avec ce dÃ©coupage, voilÃ  mon arborescence au complet</summary>

```
app/
â”œâ”€ components/
â”œâ”€ features/
â”‚  â”œâ”€ blog/
â”‚  â”‚  â”œâ”€ components/
â”‚  â”‚  â”œâ”€ loaders/
â”‚  â”‚  â”œâ”€ pages/
â”‚  â”‚  â”œâ”€ styles/
â”‚  â”‚  â”œâ”€ types/
â”‚  â”‚  â”œâ”€ utils/
â”‚  â”œâ”€ github/
â”‚  â”‚  â”œâ”€ api/
â”‚  â”‚  â”œâ”€ components/
â”‚  â”‚  â”œâ”€ loaders/
â”‚  â”‚  â”œâ”€ pages/
â”‚  â”‚  â”œâ”€ types/
â”‚  â”œâ”€ home/
â”‚  â”‚  â”œâ”€ pages/
â”œâ”€ routes/
â”œâ”€ utils/
public/
```

</details>

---

Le dÃ©coupage par features permet de trÃ¨s facilement regrouper des fonctionnalitÃ©s sans pour autant "sur-dÃ©couper". Ici, pas besoin d'avoir un dossier pour ma page "repos" et un autre pour ma page "stars" alors que ces deux pages partagent quelque chose comme 80% de leur code.

Avoir un dÃ©coupage par feature permet aussi de facilement configurer Typescript pour qu'il rÃ©solve des alias. Par exemple, dans mon `tsconfig.json` j'ai cette partie :

```json {14-21}
{
	"include": ["remix.env.d.ts", "**/*.ts", "**/*.tsx"],
	"compilerOptions": {
		"lib": ["DOM", "DOM.Iterable", "ES2019"],
		"isolatedModules": true,
		"esModuleInterop": true,
		"jsx": "react-jsx",
		"moduleResolution": "node",
		"resolveJsonModule": true,
		"target": "ES2019",
		"module": "esnext",
		"strict": true,
		"baseUrl": ".",
		"paths": {
			"~/*": ["./app/*"],
			"@components/*": [
				"./app/components/*",
				"./app/features/blog/components/*",
				"./app/features/github/components/*",
				"./app/features/home/components/*"
			],
			"@blog/*": ["./app/features/blog/*"],
			"@github/*": ["./app/features/github/*"],
			"@home/*": ["./app/features/github/*"]
		},
		"noEmit": true
	}
}
```

Ã‡a me permet plus tard d'accÃ©der Ã  mes features en faisant `import { Tabs } from '@blog/components/tabs'` par exemple.  
La configuration `@components/*` devait me permettre d'accÃ©der facilement Ã  n'importe quel composant, notamment depuis mes articles. Pour l'instant je n'ai pas eu besoin d'importer de composant autres que les bloc de codes Ã  onglet que vous avez dÃ©jÃ  pu voir.

### Mise en place de Tailwind

Pour installer Tailwind d'une faÃ§on qui me convenais sur Remix Template, j'ai utilisÃ© PostCSS et le plugin Tailwind.  
Cette approche est plus flexible et permet d'installer d'autres plugins que je trouve intÃ©ressant comme `autoprefixer` par exemple.

Pour mon site, j'ai dÃ©cidÃ© de n'utiliser que Tailwind "pur" sans CSS supplÃ©mentaire (dans la mesure du possible) et donc cette approche Ã©tait un peu compliquÃ© pour trop peu de chose.

Je me suis donc tournÃ© vers [remix-tailwind](https://github.com/itsMapleLeaf/remix-tailwind), un outil trÃ¨s simple que je vous recommande si vous avez besoin de rapidement intÃ©grer Tailwind dans vos projets Remix.

#### Remix-Tailwind

Pour installer `remix-tailwind` rien de plus simple, installez les paquets npm `remix-tailwind`, `tailwindcss` et `postcss`, gÃ©nÃ©rez votre configuration Tailwind comme d'habitude avec `npx tailwindcss init` et ensuite il est simplement question d'ajouter une route Ã  votre application qui aura pour but de construire le fichier CSS de Tailwind puis de le servir.

La documentation conseille par exemple de crÃ©er un fichier `app/route/tailwindcss.ts` et d'y ajouter ce code trÃ¨s simple :

```typescript
import type { LoaderFunction } from "remix";
import { serveTailwindCss } from "remix-tailwind";

export const loader: LoaderFunction = () => serveTailwindCss();
```

D'abord on importe `remix-tailwind`, puis on dÃ©clare un loader qui aura pour but de compiler un fichier CSS avec PostCSS et de le servir en temps qu'asset statique.

Dans mon cas j'avais aussi besoin de reprendre un peu la main sur Tailwind, et ajouter une pointe de CSS manuel (bah oui quand mÃªme ğŸ˜) et donc j'ai spÃ©cifiÃ© un fichier CSS en particulier Ã  la fonction `serveTailwindCss()`.

Pas besoin de plus que Ã§a, c'est parfait pour moi !

### PWA ready

Pour que les navigateurs puissent afficher une invitation d'installation de mon site aux utilisateurs, et aussi mettre en cache encore plus de donnÃ©es, j'ai mis en place un Service Worker avec un manifeste d'application.  
Sans rentrer dans les dÃ©tails voilÃ  comment j'ai fait Ã§a.

#### Le service worker

Tout d'abord, le plus intÃ©ressant, le service worker lui mÃªme, appelÃ© `sw.js` et servi comme un asset statique dans le dossier `./public`.  
Il Ã©coute deux actions, la premiÃ¨re c'est toutes les requÃªtes qui sortent de mon application.

<Tabs tabs={['Extrait de sw.js']}>

```javascript
// On s'abonne Ã  toutes les requÃªtes sortantes
self.addEventListener("fetch", (event) => {
	// On rÃ©cupÃ¨re des infos sur cette requÃªte
	let url = new URL(event.request.url);
	let method = event.request.method;

	// On ignore toutes les requÃªtes autre que GET car notre but c'est de mettre en cache des donnÃ©es
	if (method.toLowerCase() !== "get") return;

	// On filtre pour ne se concentrer que sur certaines donnÃ©es :
	if (
		url.pathname.startsWith("/assets/") || // On met en cache les assets (icones, fonts, images...)
		url.pathname.startsWith("/build/") || // On met en cache les fichiers de build de Remix (bundle js)
		url.pathname.startsWith("/tailwindcss") || // On met en cache le rÃ©sultat du fichier css gÃ©nÃ©rÃ© de TW ()
		url.hostname.includes("fonts.gstatic.com") // On met en cache les fonts chargÃ©es depuis Google Fonts
	) {
		// Dans le cas oÃ¹ on veux s'occuper de cette requÃªte...
		event.respondWith(
			// ...on commence par ouvrir le cache du navigateur (Ã  une version prÃ©cise, voir plus loin)
			caches.open(version).then(async (cache) => {
				// Si on trouve cette donnÃ©e dans notre cache, on la retourne simplement
				let cacheResponse = await cache.match(event.request);
				if (cacheResponse) return cacheResponse;

				// Si elle n'est pas encore mise en cache, on la rÃ©cupÃ¨re normalement et on la met en cache
				// comme Ã§a la prochaine requÃªte sera servie depuis le cache
				let fetchResponse = await fetch(event.request);
				cache.put(event.request, fetchResponse.clone());

				return fetchResponse;
			})
		);
	}
});
```

</Tabs>

Mise Ã  part la syntaxe qui n'est pas forcÃ©ment Ã©vidente d'elle mÃªme, le fonctionnement du service worker est clair et il permet d'avoir un grand contrÃ´le sur les donnÃ©es mises en cache.

La deuxiÃ¨me action qu'Ã©coute le service worker, c'est l'action d'activation de ce dernier, qui s'effectue au lancement d'une page.  
Dans cet Ã©vÃ©nement, j'en profite pour supprimer du cache toutes les donnÃ©es qui ont probablement changÃ© depuis ma derniÃ¨re mise en production.

Pour purger le cache, j'utilise un systÃ¨me finalement trÃ¨s peu versatile mais extrÃªmement simple et efficace : un numÃ©ro de version.

<Tabs tabs={['Extrait de sw.js']}>

```javascript
// Ici c'est la version du service worker, que j'incrÃ©ment quand je change une donnÃ©e dÃ©jÃ  mise en cache chez un utilisateur
const version = "1.0.2";

// On s'abonne Ã  l'Ã©venement d'activation
self.addEventListener("activate", (event) => {
	event.waitUntil(
		// On boucle sur chaques donnÃ©es mise en cache...
		caches.keys().then((keys) => {
			return Promise.all(
				keys.map((cache) => {
					// ...et si la version est diffÃ©rente de la version actuelle
					// on supprime la donnÃ©e en cache
					if (cache != version) {
						return caches.delete(cache);
					}
				})
			);
		})
	);
});
```

</Tabs>

Ce systÃ¨me permet donc d'Ã©viter que les utilisateurs gardent en cache la mauvaise version du fichier css de Tailwind par exemple.  
Le seul bÃ©mol c'est qu'il faut penser Ã  l'incrÃ©menter, mais cet inconvÃ©nient est rapidement oubliÃ© car j'ai pris l'habitude d'incrÃ©menter aussi la version dans le `package.json`.

#### Lancement du service worker

Le problÃ¨me avec les service workers c'est qu'en mode dÃ©veloppement c'est trÃ¨s dÃ©sagrÃ©able d'avoir ce cache car les donnÃ©es changent forcÃ©ment souvent et qu'il est hors de question d'incrÃ©menter le numÃ©ro de version Ã  chacun de ces petits changement.

Pour dÃ©sactiver le lancement de mon service worker j'ai dÃ©cidÃ© d'ajouter un "lanceur" que j'ajoute au html de mes rÃ©ponses ou non, selon le mode (dev ou prod).

D'abord voici le lanceur :

```javascript
// On regarde si le navigateur supporte les services workers
if ("serviceWorker" in navigator) {
	// On attend le chargement de la page...
	window.addEventListener("load", () => {
		// ...et on enregistre le service worker (il va s'activer automatiquement)
		navigator.serviceWorker.register("/sw.js");
	});
}
```

C'est un script trÃ¨s simpliste, pas besoin de s'Ã©tendre plus que Ã§a dessus donc voilÃ  comment je change son activation en fonction du mode.

<Tabs tabs={['Extrait de root.tsx']}>

```tsx {13-15}
export default function App() {
	return (
		<html className="h-full" lang="en" prefix="og: https://ogp.me/ns#">
			<head>
				<meta charSet="utf-8" />
				{/* ... */}
			</head>
			<body className="h-full">
				<Outlet />
				<RouteChangeAnnouncement />
				<ScrollRestoration />
				<Scripts />
				{process.env.NODE_ENV != "development" ? (
					<script src="/sw_launcher.js" />
				) : null}
				{process.env.NODE_ENV == "development" ? <LiveReload /> : null}
			</body>
		</html>
	);
}
```

</Tabs>

De la mÃªme maniÃ¨re que Remix active ou non son `<LiveReload />`, j'ajoute mon lanceur uniquement en mode autre que `development`.  
Encore une fois, c'est peut-Ãªtre un peu simpliste, mais Ã§a fonctionne trÃ¨s bien et je n'ai pas besoin de plus que Ã§a.

#### Le manifest

Enfin, pour obtenir une belle application lors de l'installation de la PWA il faut fournir un fichier `manifest.json` qui contient des informations nÃ©cessaire comme le titre, la couleur, les icÃ´nes etc. :

```json
{
	"name": "Quentin Widlocher",
	"short_name": "Quentin Widlocher",
	"description": "ğŸ‡«ğŸ‡· French web developer, amateur game developer and a learning enthusiast !",
	"start_url": "/",
	"icons": [
		{
			"src": "assets/icons/android-chrome-192x192.png",
			"sizes": "192x192",
			"type": "image/png"
		},
		{
			"src": "assets/icons/android-chrome-512x512.png",
			"sizes": "512x512",
			"type": "image/png"
		}
	],
	"theme_color": "#0EA5E9",
	"background_color": "#1E293B",
	"display": "standalone"
}
```

Et pour fournir ce manifeste, je l'ajoute simplement aux liens de ma page dans `root.tsx` :

<Tabs tabs={['Extrait de root.tsx']}>

```tsx {6,16}
export const links: LinksFunction = () => {
	return [
		{ rel: "stylesheet", href: cssuiCore },
		{ rel: "stylesheet", href: cssuiTooltip },
		{ rel: "stylesheet", href: "/tailwindcss" },
		{ rel: "manifest", href: "/manifest.json" },
	];
};

export default function App() {
	return (
		<html className="h-full" lang="en" prefix="og: https://ogp.me/ns#">
			<head>
				<meta charSet="utf-8" />
				{/* ... */}
				<Links />
			</head>
			<body className="h-full">
				<Outlet />
				<RouteChangeAnnouncement />
				<ScrollRestoration />
				<Scripts />
				{process.env.NODE_ENV != "development" ? (
					<script src="/sw_launcher.js" />
				) : null}
				{process.env.NODE_ENV === "development" ? <LiveReload /> : null}
			</body>
		</html>
	);
}
```

</Tabs>

Et c'est tout, maintenant, quand dÃ©ployÃ© sur une url en `https://`, certains navigateurs (comme Google Chrome notamment) invite l'utilisateur Ã  installer le site, ce que je vous invite aussi Ã  faire pour profiter de performances encore meilleur et de vous tenir Ã  jour sur les prochains articles ğŸ˜

Qui sait, peut-Ãªtre qu'un jour j'ajouterais des notifications natives pour tenir informÃ©s les gens qui ont installÃ© l'application (rassurez vous c'est optionnel)

Prochain chapitre, la connexion Ã  Github !
